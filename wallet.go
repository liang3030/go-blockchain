package main

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"

	"golang.org/x/crypto/ripemd160"
)

const wallet_version = byte(0x00)

// TODO: why is 4 not 8
const addressChecksumLen = 4

type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

func NewWallet() *Wallet {
	private, public := newKeyPair()
	wallet := Wallet{private, public}
	return &wallet
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256()
	// private key is generated by the curve
	private, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		panic(err)
	}

	// public key is generated by the private key
	// In elliptic curve based algorithms, public keys are points on a curve. Thus, public keys are points on a curve.
	// Thus, a public key is a combination of X, Y coordinates.
	// In Bitcoin, these coordinates are concatenated and form a public key.
	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

	return *private, pubKey
}

/*
convert a public key to an address
1. Take the public key and hash it twice.
2. Prepend the version of the address generation algorithm to the hash.
3. Calculate the checksum by hashing the result of last step with SHA256(SHA256(payload)).The checksum is the first four bytes of the resulted hash.
4. Append the checksum to the version+PubKeyHash combinantion.
5. Encode the version+PubKeyHash+Checksum combination with Base58 encoding.
*/

func (w Wallet) GetAddress() []byte {
	// hash the public key twice
	pubKeyHash := HashPubKey(w.PublicKey)

	// pubKeyHash... passes the slice as an argument
	versionedPayload := append([]byte{wallet_version}, pubKeyHash...)

	checksum := Checksum(versionedPayload)

	fullPayload := append(versionedPayload, checksum...)

	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()

	_, err := RIPEMD160Hasher.Write(publicSHA256[:])

	if err != nil {
		panic(err)
	}

	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}

func Checksum(payload []byte) []byte {
	firstSHA := sha256.Sum256(payload)
	secondSHA := sha256.Sum256(firstSHA[:])
	return secondSHA[:addressChecksumLen]
}

func ValidateAddress(address string) bool {
	pubKeyHash, err := Base58Decode([]byte(address))

	if err != nil {
		panic(err)
	}
	actualChecksum := pubKeyHash[len(pubKeyHash)-addressChecksumLen:]
	version := pubKeyHash[0]
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-addressChecksumLen]
	targetChecksum := Checksum(append([]byte{version}, pubKeyHash...))

	return bytes.Equal(actualChecksum, targetChecksum)
}
